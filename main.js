/** rKey */
rKey = '1554f28ee87b8c3d357c64409a410bb037747942';
/** 銘柄コード */
// stockCodeList = [8411,8306,8698,6803,3250,6502,9424,9501,4712,6740,4689,8918,7238,8604,5301,6501,2768,5020,5940,7201,9263,8308,1357,4005,6702,4755,6343,7203,4503,4188,6752,3402,1605,8002,3436,8601,4764,6178,8316,4502,8515,5480,3765,6758,2914,6503,6723,8031,7211,1812,9433,8750,8802,9318,1570,3825,8001,6636,8358,8058,8705,9984,8410,9831,8848,7261,6472,5703,6098,7267,6301,1757,3323,7751,8591,8704,7647,7167,2315,6773,6504,2330,9613,6326,8359,8801,8585,6471,3356,6835,7186,2503,8572,8053,7752,5406,7270,8354,3528,3861,1919,3407,9437,6976,6479,3266,9973,8331,5401,1802,3659,3845,7180,1332,6857,4594,8795,1803,5232,5411,4004,2802,9432,8473,4902,5008,6770,1928,9503,7182,4911,5803,6255,8925,4568,7974,6506,8267,4344,6628,5108,3092,5802,1893,7202,2437,5955,1805,4528,6177,7731,1306,9508,6366,4321,5202,6625,4347,6674,6902,9502,7911,3289,8355,4042,6507,8766,8282,3197,7272,3382,9064,1491,7269,8593,3405,2160,4452,1963,6815,2181,5713,6113,6796,8630,2337,1813,9101,9143,6630,1821,2502,4651,4222,4508,8725,8233,9531,6141,3099,4901,7762,4202,3900,8113,8732,1808,6724,3753,4506,3660,4536,3686,9697,3350,9449,9005,6753,7011,3941,1719,5002,6952,7205,6632,6460,4579,4204,1925,2432,2281,1514,5333,6494,6481,7733,3111,8086,2930,9532,6104,9504,7004,9201,4751,5486,6218,4543,6841,4912,6731,8309,9506,4063,6971,4185,5563,6707,8303,8035,6754,8830,4597,6473,3401,4203,9024,2121,8252,4507,8894,6981,8334,2120,7612,2158,1850,2371,2497,7741,3632,4743,4578,8729,5938,8256,8697,6135,9076,4118,3003,1860,3315,6305,4205,7575,3236,6727,7832,5334,9509,2440,7012,9517,8789,6955,4587,3656,6762,5105,4183,5929,6383,1801,7936,6988,3086,8253,8804,4613,8897,7779,4151,8029,4523,6775,8922,5423,8927,6804,6172,7013,1689,7701,9202,3679,4324,2413,9006,9104,2385,6954,4563,8418,6508,1615,8616,4564,3727,9399,9962,5711,8524,1824,6240,7867,5110,6448,1852,4217,6268,3105,9505,2127,9507,4680,8090,2433,3655,4676,2370,4849,4293,5901,5201,5706,1360,7459,4182,7003,4062,3807,6768,8628,3938,3865,9020,7836,9519,2531,6594,8379,5727,7912,5801,5019,2427,7638,5991,6101,8714,6709,9684,2492,6480,5413,3661,1400,4519,3291,6367,6645,2338,8892,3863,4272,3773,9412,4974,3048,6967,2002,5017,6703,4927,2353,7951,6302,7224,2784,3668,4666,2579,6701,4739,6972,3793,6586,6071,2212,2193,8893,6993,6728,1822,2929,3808,6624,2144,9007,9766,2170,9069,6810,4582,3258,7532,1435,8028,6380,4208,8933,2467,3390,4704,2928,6140,3906,2685,5214,3903,8703,8609,6622,4043,6395,1721,2134,4661,6963,3284,2321,7240,8508,6588,7259,2730,8385,3647,2871,3777,8015,2060,3106,1911,4768,3687,4814,5912,2801,2666,6890,4612,9513,3231,4732,8242,5631,7518,4091,3397,3719,7732,4980,9142,6407,2038,8876,6869,5393,6371,9735,9983,4307,5233,9021,2282,8056,6495,4021,3927,8739,3696,8304,9404,6143,2267,6095,9107,6923,7148,2229,1720,4041,8005,6166,7172,2379,4978,3064,2317,5218,1443,6201,9127,6361,3132,6634,8016,6958,6370,6997,3121,5332,3853,8589,4824,7246,7915,3673,7956,7618,5302,4284,2749,6134,8366,2809,3521,5101,2587,7873,3116,2702,6440,8570,1417,6807,1951,6315,4921,1699,3186,9704,6324,4461,4571,9042,6755,6951,6771,8919,5208,2489,6794,5021,4681,2362,6088,3113,4634,3088,7735,3606,3101,6965,2146,8905,9009,7776,3843,3680,6412,5970,3103,4544,9302,4583,5103,7747,6047,4967,3300,8946,4631,3415,9753,7244,7599,7744,9001,8107,8382,4592,9904,2269,1853,7593,6005,6093,6787,6670,6235,9048,7519,3050,5357,2931,1890,4047,3747,9468,3053,2667,2389,6619,4779,2743,8439,7274,4996,8890,4061,9783,3254,2157,1944,5809,6798,7241,7276,6464,6871,8511,8136,7181,9041,8713,7513,1942,2296,5702,9303,6058,8036,6944,7282,3766,8368,7906,9980,6590,2884,1662,6050,7550,9827,6911,6013,6641,2398,7251,6920,4586,6498,7014,8544,2656,5714,4088,6417,3624,8934,8386,7745,2501,4813,8338,8201,4617,3978,8020,7198,3646,7725,3202,2875,1873,8377,8388,9301,3652,6996,5463,5704,2453,8746,4527,8912,7965,8202,5726,6175,9989,9681,7919,6055,4819,7189,6881,2651,6072,9364,7102,9843,6629,9401,5289,3082,3758,5358,1820,4922,4565,6925,6875,8614,7527,9602,5721,9416,8060,2471,7321,2706,1871,9022,4312,3902,8289,2168,4541,2331,6136,1878,4585,3245,3880,2607,2372,3626,6330,6274,9008,6879,6432,6203,6819,6146,9987,8105,3963,2206,3433,3387,6534,7545,9792,6118,6652,6541,6444,3672,6849,5949,3556,6103,3742,9997,3782,4516,6817,7988,3776,2388,9062,7157,6089,9743,8381,6941,6183,6436,5741,1333,5210,1419,3191,4847,3179,8595,6999,3756,3167,4929,9861,6995,4045,3923,1926,2461,9616,9719,2491,7844,5715,5363,6592,6966,6376,4092,8586,1861,4403,4290,8346,3994,9706,4783,8600,1833,4540,6855,6192,9419,8844,3935,2681,6856,3071,7280,4308,2670,3778,9086,2776,3664,4997,5453,4555,3457,4345,3744,6861,3187,6644,6273,8129,2412,6845,2264,4569,3391,2782,6191,7581,6131,8369,3739,6357,2593,8165,6193,9854,1866,2270,9603,3662,4028,3858,6457,7610,3784,6816,7984,1308,6914,3083,5541,7994,6425,2764,7717,3288,7164,1305,1898,1579,3201,9045,6467,3920,1885,7606,2191,2201,5857,7412,4924,2162,3912,6556,4189,5121,1459,2175,4120,4114,5122,6838,6222,4246,7908,8341,6079,1711,3271,3823,1321,2792,7309,7105,7230,6741,6927,9956,6730,3627,8783,9065,3042,4514,3762,3774,8219,7860,4820,7649,7940,3237,2811,6027,9832,9533,3040,9479,1921,5269,2678,3209,8184,9972,3791,2428,4745,3665,5950,9044,3141,8803,4331,6465,8622,1881,7313,7222,4708,7616,6081,3844,8550,8613,2479,6882,1983,8050,2897,9678,8840,6552,2810,3110,9880,3966,7613,3769,3675,9627,7718,3563,2176,4875,8078,3558,4401,9307,2327,3608,6651,2438,4186,3932,4845,5856,3134,3148,7746,6561,5381,2499,3076,6544,9450,7777,8285,8227,3975,6272,6269,5481,6409,5911,6786,9514,3036,6620,9478,6888,6028,6094,8179,8836,6082,3034,6742,1969,2307,3168,3645,9176,4684,8396,6929,3667,4917,3264,6258,4848,2124,3038,6406,5310,1916,3911,4530,6659,8114,3635,9409,5444,6200,4581,5852,4082,8012,4838,9119,6566,2154,3649,4282,9759,7729,4971,8360,6785,3328,3857,1883,4406,8088,7187,8806,6165,4368,7191,7177,3926,7161,3901,3189,3244,7966,1571,7220,6574,6418,6199,7716,3360,6145,7250,3543,4240,6246,8051,1606,4109,6197,7970,2130,9466,8186,7859,4772,1401,9744,6538,9375,8130,6839,2326,9878,9692,4714,1929,1959,8133,5707,2468,6210,4095,6345,2767,4596,3222,2874,9830,7831,6862,8095,6859,7552,9699,2341,6349,2484,4552,3685,4716,6334,6077,8935,7296,9474,3569,3989,6532,8226,1726,6379,9757,8909,8923,4665,9765,3697,6905,6474,3299,3182,6904,4206,8624,2719,7571,3267,8237,8737,9672,4576,2288,2001,3085,6065,3564,6571,7719,1678,6262,6638,4319,9090,4837,4570,2454,6339,4080,5610,2138,5216,4382,6250,1458,3916,3028,4548,3252,9945,3775,4275,2695,1366,3087,4633,3193,3107,6092,6814,9003,4521,8769,3663,2533,5471,3548,6208,8337,3678,8283,8155,8125,3689,4022,6800,5805,8218,8150,5986,3591,7453,8558,6627,6721,2340,5440,5975,5384,7420,3837,3688,8281,8715,9025,7727,8111,7245,8214,4588,8871,9992,4549,6568,5698,6772,7458,6332,1934,8135,2174,4044,8022,5851,6293,8364,3928,3230,7522,9930,8174,9948,7516,7190,3751,9511,4350,4220,9716,7864,4662,4686,8518,6187,5947,9417,3479,6194,7022,6245,3276,9031,6099,2301,4381,3666,1420,4641,6390,3641,9790,6333,8370,7862,3676,5981,9418,1430,5191,9308,6300,2159,6184,1671,5288,7818,6569,6826,7992,2734,5612,8273,4736,7199,4591,3738,7780,3475,5930,6182,4975,9435,3981,6287,7283,8818,9749,7242,9888,2384,9068,6069,6658,8929,6750,8841,7624,4998,7419,3840,8361,4572,7774,5410,3349,3447,2778,2378,1961,1377,1945,5367,8137,3319,6640,3810,3754,9913,1973,2151,7278,9928,4215,3333,6400,5959,2901,1695,6615,7294,3669,7886,6029,2183,4664,3779,2342,8093,4287,2602,3486,3031,3549,8914,7888,6677,9702,4829,3221,3852,6264,7226,6294,7947,3983,8740,3561,1518,7256,6575,4288,6347,7239,4218,1879,9740,7707,7721,6292,9957,8168,1835,8747,3851,4776,7600,3657,6196,3909,3097,1827,3445,7840,6289,6806,3242,3046,6986,4593,5817,9715,1343,3937,1379,1716,6298,6323,2722,3232,4777,9075,1979,7608,2516,3441,7868,4046,2148,4726,9793,3625,7291,3593,8098,4112,6054,8920,7972,2222,3098,1976,8850,3681,5011,2475,6284,2693,6618,9262,3151,3395,3891,9543,5192,9270,4547,2109,7995,4228,2910,6664,3788,7212,1429,7740,9072,8425,3905,4216,9467,6591,7820,6908,1844,1356,2908,6744,1949,4369,4316,3694,8999,1783,7537,6310,4348,7952,8860,5932,6482,6185,3921,6668,1935,8367,7609,4559,7730,3002,3393,9842,4626,7976,5304,6486,2698,6080,8462,4763,6266,6312,6737,6034,8707,1407,2538,7448,6364,8706,2292,8869,4187,7421,9267,6084,3917,4317,4023,2703,2352,9534,2462,8889,3760,1936,2418,4722,6918,3180,6469,7192,7247,7185,7990,1722,9682,4237,6278,7846,6463,7874,7927,2354,3385,1330,4615,3854,6656,6489,3069,4919,6555,6616,2694,3677,6545,3910,9698,6554,6985,6458,7962,6062,1848,6516,3998,4318,8276,8356,2733,1434,1968,9739,3140,4668,4812,9110,8008,4951,1418,2788,6844,2429,9363,6171,3073,9742,6384,8209,9438,9763,8742,2763,2926,4249,2150,6698,4274,9423,6340,6779,6490,3611,6238,7943,4775,8097,3196,5989,8200,4343,5988,6848,4595,6584,9039,4694,7196,8251,7483,7981,1348,1730,1814,6038,6045,3091,2335,5344,7834,3623,2915,9551,9362,2163,7520,7715,4301,3194,3653,2664,7810,3798,9990,7287,5388,8185,8127,8154,7173,5491,3836,5331,7775,2780,7567,7918,3341,4553,3723,3904,1414,5952,8399,6413,4221,3804,7183,6276,8584,2458,7611,2303,7323,8771,4928,6962,5957,6840,6277,3547,5408,6961,3159,6938,6553,3489,5976,5337,7838,4977,1384,5943,4963,4619,6926,9882,3464,1815,2815,3636,5902,5194,8068,7817,9810,6059,1941,6864,3929,8079,3010,3228,9624,3936,3842,8424,2309,3469,3030,4238,3446,7971,9422,2198,8140,6198,2590,6459,6044,3969,8708,6837,6091,3298,1950,9413,3161,6535,7590,6378,8887,6433,6188,3156,8881,1320,7771,3922,7433,4346,3431,9232,9726,3321,3967,1954,6573,3799,3997,7615,8151,8167,7271,6617,6189,6547,3864,9010,8423,5282,9722,5262,6778,4100,3580,6633,8023,7986,4767,3604,3939,1766,6537,7743,3192,8203,7821,6736,7826,4064,6445,6937,3878,1475,6916,1870,7315,9260,9946,9037,2435,6551,6282,6866,6355,3454,9895,1413,6823,3985,4286,3634,2351,5632,7856,8387,7921,4816,3940,8018,9869,2726,6381,7739,6369,9995,6176,1568,6090,8324,7839,3540,2374,5352,3692,4027,6455,6901,8279,6513,3741,3914,8291,4078,2186,4245,7855,9927,8163,9271,3539,1325,9310,4642,6327,7554,1724,6809,8139,6947,4212,4770,3277,6035,2220,3482,7494,7435,9746,4800,6319,7231,4326,6147,1914,8562,9755,2173,7445,3925,7184,2477,8541,4094,7266,3933,3169,1967];
// stockCodeList = [8698, 8306, 1357, 4689, 6501, 8604, 9501, 7201, 6723, 4005, 5020, 4755, 6702, 8308, 2768, 5301, 6178, 6752, 1570, 8601, 4503, 3436, 2914, 6758, 8316, 7211, 9831, 9433, 8031, 6503, 8410, 8002, 9984, 8750, 4502, 8001, 4188, 6301, 1605, 7203, 5406, 7261, 9437, 6472, 8802, 7267, 7751, 8058, 3402];
stockCodeList = [8698, 4689];
/** シミュレート日数 */
simulateDay = 3600;
/** APIを1回呼ぶごとの待ち時間(ミリ秒) */
intervalTime = 1000;
/** 何個目の銘柄を処理中か */
var progressNumber = 0;
/** 取引1回あたりにかかる手数料(%) */
const fee = 0;
/** 購入条件(0:成行 1:現在値指値 2:現在値指値/利確) */
var purchasePattern = 0;
const PATTERN_NARIYUKI = 0;
const PATTERN_GENZAINESASHINE = 1;
const PATTERN_GENZAINESASHINE_RIKAKU = 2;
/** 価格帯絞り込みの範囲 */
var priceBandLow = 0;
var priceBandHigh = 999999;
/** 価格帯別グラフの目盛り */
const priceRangeScale = [50, 100, 200, 300, 400, 600, 800, 1200, 1600, 3200, 4800, 6400, 12800, 25600];
/** 期間別グラフの目盛り */
const periodScale = ['2004', '2005', '2006', '2007', '2008', '2009', '2010', '2011', '2012', '2013', '2014', '2015', '2016', '2017', '2018'];
/** 適当買いシミュレート時の生成する乱数の数( 1/??? の確率で購入) */
var purchaseTriggerRandomNumber = 100;
/** 下ヒゲシミュレート時の購入条件とする下ヒゲの長さ(%) */
var purchaseTriggerLowerShadowLength = 8;
/** 上ヒゲシミュレート時の購入条件とする上ヒゲの長さ(%) */
var purchaseTriggerUpperShadowLength = 8;
/** 2連下ヒゲシミュレート時の購入条件とする下ヒゲの長さ(%) */
var purchaseTrigger2RenLsLength = 3;
/** 底値下ヒゲシミュレート時の過去何本の足を見て底値と判断するか */
var areasJudgementStandardLsInBottom = 60;
/** 底値下ヒゲシミュレート時の購入条件とする下ヒゲの長さ(%) */
var purchaseTriggerLsInBottomLength = 3;
/** 赤三兵の最後の足で出た場合に無効とする上ヒゲの長さ */
var invalidUsInAkasanpei = 1;
/** シミュレート結果(ランダム) */
randomResult = [];
/** シミュレート結果(下ヒゲ) */
lowerShadowResult = [];
/** シミュレート結果(上ヒゲ) */
upperShadowResult = [];
/** シミュレート結果(2連下ヒゲ) */
LowerShadow2RenResult = [];
/** シミュレート結果(底値下ヒゲ) */
LsInBottomResult = [];
/** シミュレート結果(確定的ダブルはらみ) */
doubleHaramiResult = [];
/** シミュレート結果(赤三兵) */
akasanpeiResult = [];

pricesListList = new Object();




window.onload = function () {
    $("#purchase_trigger_input_ls").val(purchaseTriggerLowerShadowLength);
    $("#purchase_trigger_input_us").val(purchaseTriggerUpperShadowLength);
    $("#purchase_trigger_input_2ren_ls").val(purchaseTrigger2RenLsLength);
    $("#areas_judgement_standard_input").val(areasJudgementStandardLsInBottom);
    $("#purchase_trigger_input_ls_inbottom").val(purchaseTriggerLsInBottomLength);
    $("#invalid_us_in_akasanpei_input").val(invalidUsInAkasanpei);

    $('#price_band_low').val(priceBandLow);
    $('#price_band_high').val(priceBandHigh);
}


function start() {

    getStockData();
    simulateAndShowResult();
    console.log('価格絞り込み＝' + priceBandLow + '~' + priceBandHigh);

}


function getStockData() {

    var codeCount = 0;
    var bunkatu = [];
    for (var i = 0; i < 9999; i++) {
        const result = readTextFile('https://s3-ap-northeast-1.amazonaws.com/ev-checker-data/' + (i + 1301) + '.txt');
        if (result) {
            for (var j = 0; j < result.prices.length; j++) {
                const strDate = result.prices[j].date.split('-');
                result.prices[j].date = new Date(strDate[0], strDate[1] - 1, strDate[2], 15);
                result.prices[j].us = calcUpperShadow(result.prices[j].open, result.prices[j].high, result.prices[j].low, result.prices[j].close);
                result.prices[j].ls = calcLowerShadow(result.prices[j].open, result.prices[j].high, result.prices[j].low, result.prices[j].close);
                // 足の種類。ちょっと珍しいかもだけどイメージしやすいように1,0,-1で区別(1:陽線 0:ぺったんこ -1:陰線)
                if ((result.prices[j].close - result.prices[j].open) > 0) {
                    // 終値が始値より大きければ陽線
                    result.prices[j].barType = 1;
                } else if ((result.prices[j].close - result.prices[j].open) < 0) {
                    // 終値が始値より小さければ陰線
                    result.prices[j].barType = -1;
                } else {
                    // どっちでもなければぺったんこ
                    result.prices[j].barType = 0;
                }
            }


            /**
             * 異常なデータを検出する。
             * わざわざ関数作った理由は、関数作らずに普通に書くとまたbreakFlag的なbreakしたことを表すフラグを用意しないといけなくなり
             * なんかダサかったので、普通じゃないやり方かもしれないけど関数にすることでreturnでいい感じにした。
             */
            function checkDataNormal() {
                for (var j = 0; j < result.prices.length; j++) {
                    const prices = result.prices[j];
                    if (prices.open <= 0 || prices.high <= 0 || prices.low <= 0 || prices.close <= 0
                        || prices.us < 0 || prices.ls < 0 || prices.barType <= -2 || prices.barType >= 2) {
                        // ここ、本来はbreakFlagをtrueにしてbreakしたりしなきゃいけなかった。関数にすることでスマートになった。気がする。
                        return false;
                    }
                }
                return true;
            }

            const isDataNormal = checkDataNormal();
            if (!isDataNormal) {
                console.log('異常なデータを検出');
                continue;
            }

            /*
            過去に分割されたことがあるかどうかを調べる。
            分割されてるっぽかったら、スルーしてサンプルから除外する。
            これは一時的な応急処置であり、そのうちちゃんと直したい。
            とは言っても分割に関する処理は本当に難しい。。
            */
            if (result.prices.length > 0) {
                var priceBeforeOneDay = result.prices[0].open;
                var bunkatuFlag = false;
                for (var j = 1; j < result.prices.length; j++) {
                    // １日で始値が倍以上、または半分以下になっていた場合、分割と判断
                    if (result.prices[j].open >= priceBeforeOneDay * 2
                        || result.prices[j].open <= priceBeforeOneDay / 2) {
                        bunkatuFlag = true;
                    }

                    priceBeforeOneDay = result.prices[j].open;
                }

                if (bunkatuFlag) {
                    console.log('分割が見つかったのでスルーします');
                    bunkatu.push(result.code);
                    continue;
                }
            }


            result.prices.reverse();

            pricesListList[codeCount + ''] = result;
            console.log(result);
            codeCount++;
        } else {
        }
    }
    console.log('EVdata構成完了');
    console.log(pricesListList);
    console.log('分割により、' + bunkatu.length + '件の銘柄を除外');
    console.log('分割銘柄一覧', bunkatu);
}

/**
 * ネットから拾ってきたファイル読み込むための関数
 * @param {string} 読み込みたいファイルのパス(URL)
 */
function readTextFile(url) {
    var rawFile = new XMLHttpRequest();
    rawFile.open("GET", url, false);
    rawFile.send(null);
    try {
        const resultJson = JSON.parse(rawFile.responseText);
        return resultJson;
    } catch (e) {
    }


}


function put() {

    console.log(pricesListList);

    var url = 'https://s7shrdbypi.execute-api.ap-northeast-1.amazonaws.com/stage1';
    console.log('json作りまーす');
    var reqData = {
        situon: '俺たちは人'
    }
    const reqStr = JSON.stringify(reqData);
    console.log(reqStr);
    console.log('いきますー', url);
    $.ajax({
        url: url,
        type: 'PUT',
        dataType: 'json',
        data: reqStr,
        timeout: 10000
    }// Ajaxリクエストが成功した時発動
    ).done(function (data) {
        console.log('done+++');
        console.log(data);
    })
        // Ajaxリクエストが失敗した時発動
        .fail(function (data) {
            console.log('fail---');
            console.log(data);
        })
}



function qrapiCallback_2(response) {

    progressNumber++;
    document.getElementById('progress').innerText = progressNumber + '/' + stockCodeList.length;

    var pricesList = new Object();
    pricesList['code'] = (response[0].code + '').split('/')[0];
    var tmpPriceListList = [];
    for (var i = 0; i < response[0].data.length; i++) {
        var tmpPriceList = new Object;
        // それぞれのデータを変数に格納する
        var date = response[0].data[i][0];
        var open = response[0].data[i][1];
        var high = response[0].data[i][2];
        var low = response[0].data[i][3];
        var close = response[0].data[i][4];
        var turnover = response[0].data[i][5];

        var upperShadow = calcUpperShadow(open, high, low, close);
        var lowerShadow = calcLowerShadow(open, high, low, close);

        tmpPriceList['date'] = new Date(date);
        tmpPriceList['open'] = open;
        tmpPriceList['high'] = high;
        tmpPriceList['low'] = low;
        tmpPriceList['close'] = close;
        tmpPriceList['turnover'] = turnover;
        // us = upper shadow
        tmpPriceList['us'] = upperShadow;
        // ls = lower shadow
        tmpPriceList['ls'] = lowerShadow;

        // 足の種類。ちょっと珍しいかもだけどイメージしやすいように1,0,-1で区別(1:陽線 0:ぺったんこ -1:陰線)
        if ((close - open) > 0) {
            // 終値が始値より大きければ陽線
            tmpPriceList['barType'] = 1;
        } else if ((close - open) < 0) {
            // 終値が始値より小さければ陰線
            tmpPriceList['barType'] = -1;
        } else {
            // どっちでもなければぺったんこ
            tmpPriceList['barType'] = 0;
        }

        tmpPriceListList.push(tmpPriceList);
    }
    pricesList['prices'] = tmpPriceListList;

    pricesListList[progressNumber] = pricesList;

    console.log(pricesList);
}


/**
 * ランダムでのシミュレーション。そもそも適当にトレードしたらどうなるのかをシミュレートする
 */
function simulateRandam() {

    const pricesListNum = Object.keys(pricesListList).length;
    if (pricesListNum == 0) {
        return;
    }
    randomResult.length = 0;
    for (var listListIndex = 0; listListIndex < pricesListNum; listListIndex++) {
        var pricesList = pricesListList[listListIndex];
        for (var i = 0; i < pricesList.prices.length; i++) {

            // 価格帯絞り込みの範囲外の値段のものはスルーする
            if (Number(pricesList.prices[i].close) < priceBandLow || Number(pricesList.prices[i].close) > priceBandHigh) {
                continue;
            }

            // 0~99の乱数
            var random = Math.floor(Math.random() * purchaseTriggerRandomNumber);

            // 乱数が特定の数字になったら購入(ランダム購入)
            if (random == 0) {
                // 購入時は次の足の始値で購入するため、次の足が存在しない場合はスルー
                if (!pricesList.prices[i + 1]) {
                    break;
                }

                if (purchasePattern == PATTERN_NARIYUKI) {
                    // 次の足の始値で購入する。購入時点のデータを記憶しておく。bid=入札、らしい
                    const pricesAtBid = pricesList.prices[i + 1];
                    pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                    i++;
                    for (; i < pricesList.prices.length; i++) {
                        // 購入後、陰線が出るまで保有し続ける。陰線が出たら売却。売却時も次の足の始値で売却するため、次の足のデータが存在しない場合はスルーする。
                        if (pricesList.prices[i].barType == -1) {
                            if (!pricesList.prices[i + 1]) {
                                break;
                            }
                            // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                            const pricesAtSell = pricesList.prices[i + 1];
                            pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                            const tmpResult = new Object();
                            tmpResult['code'] = pricesList.code;
                            tmpResult['bid'] = pricesAtBid;
                            tmpResult['sell'] = pricesAtSell;
                            randomResult.push(tmpResult);
                            i--;
                            break;
                        }
                    }
                }
                else if (purchasePattern == PATTERN_GENZAINESASHINE) {
                    if (pricesList.prices[i].close == pricesList.prices[i + 1].open) {
                        // 当足の終値と次の足の始値が一緒だった場合にのみ購入する。これも次の足の始値で購入。
                        const pricesAtBid = pricesList.prices[i + 1];
                        pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                        i++;
                        for (; i < pricesList.prices.length; i++) {
                            // 購入後、陰線が出るまで保有し続ける。陰線が出たら売却。売却時も次の足の始値で売却するため、次の足のデータが存在しない場合はスルーする。
                            if (pricesList.prices[i].barType == -1) {
                                if (!pricesList.prices[i + 1]) {
                                    break;
                                }
                                // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                                const pricesAtSell = pricesList.prices[i + 1];
                                pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                                const tmpResult = new Object();
                                tmpResult['code'] = pricesList.code;
                                tmpResult['bid'] = pricesAtBid;
                                tmpResult['sell'] = pricesAtSell;
                                randomResult.push(tmpResult);
                                i--;
                                break;
                            }
                        }
                    }
                } else if (purchasePattern == PATTERN_GENZAINESASHINE_RIKAKU) {
                    if (pricesList.prices[i].close == pricesList.prices[i + 1].open) {
                        // 当足の終値と次の足の始値が一緒だった場合にのみ購入する。これも次の足の始値で購入。
                        const pricesAtBid = pricesList.prices[i + 1];
                        pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                        i++;
                        var sashine = 0;
                        for (; i < pricesList.prices.length; i++) {

                            /*
                            指値を下回った場合、売却する。
                            その足の安値が指値を下回っていた場合、その足の途中で指値を突破したことが確定するので、
                            その足の安値が指値を下回っていた場合に指値で売却処理をする
                            */
                            if (pricesList.prices[i].low <= sashine) {
                                const pricesAtSell = pricesList.prices[i];

                                /*
                                基本的に指値の値段で売却することになるが、当足がめっちゃ窓開けて下げてスタートした場合、
                                始値が指値を下回ってしまうことがあるので、その場合はもちろん指値で売ることは不可能なので
                                始値で売却処理をする
                                */
                                if (sashine <= pricesList.prices[i].open) {
                                    pricesAtSell.sellingPrice = sashine;
                                } else {
                                    pricesAtSell.sellingPrice = pricesList.prices[i].open;
                                }

                                const tmpResult = new Object();
                                tmpResult['code'] = pricesList.code;
                                tmpResult['bid'] = pricesAtBid;
                                tmpResult['sell'] = pricesAtSell;
                                randomResult.push(tmpResult);
                                i--;
                                break;
                            }

                            else if (pricesList.prices[i].barType == -1) {
                                if (!pricesList.prices[i + 1]) {
                                    break;
                                }
                                // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                                const pricesAtSell = pricesList.prices[i + 1];
                                pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                                const tmpResult = new Object();
                                tmpResult['code'] = pricesList.code;
                                tmpResult['bid'] = pricesAtBid;
                                tmpResult['sell'] = pricesAtSell;
                                randomResult.push(tmpResult);
                                i--;
                                break;
                            } else {
                                // 利確のために1本前の終値で指値を入れる
                                sashine = pricesList.prices[i - 1].close;
                            }
                        }
                    }
                }

            }
        }
    }

}

/**
 * 下ヒゲでのシミュレーション
 */
function simulateLowerShadow() {

    const pricesListNum = Object.keys(pricesListList).length;
    if (pricesListNum == 0) {
        return;
    }
    lowerShadowResult.length = 0;
    for (var listListIndex = 0; listListIndex < pricesListNum; listListIndex++) {
        var pricesList = pricesListList[listListIndex];
        for (var i = 0; i < pricesList.prices.length; i++) {

            // 価格帯絞り込みの範囲外の値段のものはスルーする
            if (Number(pricesList.prices[i].close) < priceBandLow || Number(pricesList.prices[i].close) > priceBandHigh) {
                continue;
            }

            // 下ヒゲが一定の長さを超えたら購入
            if (pricesList.prices[i].ls >= purchaseTriggerLowerShadowLength) {
                // 購入時は次の足の始値で購入するため、次の足が存在しない場合はスルー
                if (!pricesList.prices[i + 1]) {
                    break;
                }

                if (purchasePattern == PATTERN_NARIYUKI) {
                    // 次の足の始値で購入する。購入時点のデータを記憶しておく。bid=入札、らしい
                    const pricesAtBid = pricesList.prices[i + 1];
                    pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                    i++;
                    for (; i < pricesList.prices.length; i++) {
                        // 購入後、陰線が出るまで保有し続ける。陰線が出たら売却。売却時も次の足の始値で売却するため、次の足のデータが存在しない場合はスルーする。
                        if (pricesList.prices[i].barType == -1) {
                            if (!pricesList.prices[i + 1]) {
                                break;
                            }
                            // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                            const pricesAtSell = pricesList.prices[i + 1];
                            pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                            const tmpResult = new Object();
                            tmpResult['code'] = pricesList.code;
                            tmpResult['bid'] = pricesAtBid;
                            tmpResult['sell'] = pricesAtSell;
                            lowerShadowResult.push(tmpResult);
                            i--;
                            break;
                        }
                    }
                }
                else if (purchasePattern == PATTERN_GENZAINESASHINE) {
                    if (pricesList.prices[i].close == pricesList.prices[i + 1].open) {
                        // 当足の終値と次の足の始値が一緒だった場合にのみ購入する。これも次の足の始値で購入。
                        const pricesAtBid = pricesList.prices[i + 1];
                        pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                        i++;
                        for (; i < pricesList.prices.length; i++) {
                            // 購入後、陰線が出るまで保有し続ける。陰線が出たら売却。売却時も次の足の始値で売却するため、次の足のデータが存在しない場合はスルーする。
                            if (pricesList.prices[i].barType == -1) {
                                if (!pricesList.prices[i + 1]) {
                                    break;
                                }
                                // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                                const pricesAtSell = pricesList.prices[i + 1];
                                pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                                const tmpResult = new Object();
                                tmpResult['code'] = pricesList.code;
                                tmpResult['bid'] = pricesAtBid;
                                tmpResult['sell'] = pricesAtSell;
                                lowerShadowResult.push(tmpResult);
                                i--;
                                break;
                            }
                        }
                    }
                }
                else if (purchasePattern == PATTERN_GENZAINESASHINE_RIKAKU) {
                    if (pricesList.prices[i].close == pricesList.prices[i + 1].open) {
                        // 当足の終値と次の足の始値が一緒だった場合にのみ購入する。これも次の足の始値で購入。
                        const pricesAtBid = pricesList.prices[i + 1];
                        pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                        i++;
                        var sashine = 0;
                        for (; i < pricesList.prices.length; i++) {

                            /*
                            指値を下回った場合、売却する。
                            その足の安値が指値を下回っていた場合、その足の途中で指値を突破したことが確定するので、
                            その足の安値が指値を下回っていた場合に指値で売却処理をする
                            */
                            if (pricesList.prices[i].low <= sashine) {
                                const pricesAtSell = pricesList.prices[i];

                                /*
                                基本的に指値の値段で売却することになるが、当足がめっちゃ窓開けて下げてスタートした場合、
                                始値が指値を下回ってしまうことがあるので、その場合はもちろん指値で売ることは不可能なので
                                始値で売却処理をする
                                */
                                if (sashine <= pricesList.prices[i].open) {
                                    pricesAtSell.sellingPrice = sashine;
                                } else {
                                    pricesAtSell.sellingPrice = pricesList.prices[i].open;
                                }

                                const tmpResult = new Object();
                                tmpResult['code'] = pricesList.code;
                                tmpResult['bid'] = pricesAtBid;
                                tmpResult['sell'] = pricesAtSell;
                                lowerShadowResult.push(tmpResult);
                                i--;
                                break;
                            }

                            else if (pricesList.prices[i].barType == -1) {
                                if (!pricesList.prices[i + 1]) {
                                    break;
                                }
                                // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                                const pricesAtSell = pricesList.prices[i + 1];
                                pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                                const tmpResult = new Object();
                                tmpResult['code'] = pricesList.code;
                                tmpResult['bid'] = pricesAtBid;
                                tmpResult['sell'] = pricesAtSell;
                                lowerShadowResult.push(tmpResult);
                                i--;
                                break;
                            } else {
                                // 利確のために1本前の終値で指値を入れる
                                sashine = pricesList.prices[i - 1].close;
                            }
                        }
                    }
                }
            }
        }
    }
}

/**
 * 上ヒゲでのシミュレーション
 */
function simulateUpperShadow() {

    const pricesListNum = Object.keys(pricesListList).length;
    if (pricesListNum == 0) {
        return;
    }
    upperShadowResult.length = 0;
    for (var listListIndex = 0; listListIndex < pricesListNum; listListIndex++) {
        var pricesList = pricesListList[listListIndex];

        for (var i = 0; i < pricesList.prices.length; i++) {

            // 価格帯絞り込みの範囲外の値段のものはスルーする
            if (Number(pricesList.prices[i].close) < priceBandLow || Number(pricesList.prices[i].close) > priceBandHigh) {
                continue;
            }

            // 下ヒゲが一定の長さを超えたら購入
            if (pricesList.prices[i].us >= purchaseTriggerUpperShadowLength) {
                // 購入時は次の足の始値で購入するため、次の足が存在しない場合はスルー
                if (!pricesList.prices[i + 1]) {
                    break;
                }
                if (purchasePattern == PATTERN_NARIYUKI) {
                    // 次の足の始値で購入する。購入時点のデータを記憶しておく。bid=入札、らしい
                    const pricesAtBid = pricesList.prices[i + 1];
                    pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                    i++;
                    for (; i < pricesList.prices.length; i++) {
                        // 購入後、陰線が出るまで保有し続ける。陰線が出たら売却。売却時も次の足の始値で売却するため、次の足のデータが存在しない場合はスルーする。
                        if (pricesList.prices[i].barType == -1) {
                            if (!pricesList.prices[i + 1]) {
                                break;
                            }
                            // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                            const pricesAtSell = pricesList.prices[i + 1];
                            pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                            const tmpResult = new Object();
                            tmpResult['code'] = pricesList.code;
                            tmpResult['bid'] = pricesAtBid;
                            tmpResult['sell'] = pricesAtSell;
                            upperShadowResult.push(tmpResult);
                            i--;
                            break;
                        }
                    }
                }
                else if (purchasePattern == PATTERN_GENZAINESASHINE) {
                    if (pricesList.prices[i].close == pricesList.prices[i + 1].open) {
                        // 当足の終値と次の足の始値が一緒だった場合にのみ購入する。これも次の足の始値で購入。
                        const pricesAtBid = pricesList.prices[i + 1];
                        pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                        i++;
                        for (; i < pricesList.prices.length; i++) {
                            // 購入後、陰線が出るまで保有し続ける。陰線が出たら売却。売却時も次の足の始値で売却するため、次の足のデータが存在しない場合はスルーする。
                            if (pricesList.prices[i].barType == -1) {
                                if (!pricesList.prices[i + 1]) {
                                    break;
                                }
                                // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                                const pricesAtSell = pricesList.prices[i + 1];
                                pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                                const tmpResult = new Object();
                                tmpResult['code'] = pricesList.code;
                                tmpResult['bid'] = pricesAtBid;
                                tmpResult['sell'] = pricesAtSell;
                                upperShadowResult.push(tmpResult);
                                i--;
                                break;
                            }
                        }
                    }
                } else if (purchasePattern == PATTERN_GENZAINESASHINE_RIKAKU) {
                    if (pricesList.prices[i].close == pricesList.prices[i + 1].open) {
                        // 当足の終値と次の足の始値が一緒だった場合にのみ購入する。これも次の足の始値で購入。
                        const pricesAtBid = pricesList.prices[i + 1];
                        pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                        i++;
                        var sashine = 0;
                        for (; i < pricesList.prices.length; i++) {

                            /*
                            指値を下回った場合、売却する。
                            その足の安値が指値を下回っていた場合、その足の途中で指値を突破したことが確定するので、
                            その足の安値が指値を下回っていた場合に指値で売却処理をする
                            */
                            if (pricesList.prices[i].low <= sashine) {
                                const pricesAtSell = pricesList.prices[i];

                                /*
                                基本的に指値の値段で売却することになるが、当足がめっちゃ窓開けて下げてスタートした場合、
                                始値が指値を下回ってしまうことがあるので、その場合はもちろん指値で売ることは不可能なので
                                始値で売却処理をする
                                */
                                if (sashine <= pricesList.prices[i].open) {
                                    pricesAtSell.sellingPrice = sashine;
                                } else {
                                    pricesAtSell.sellingPrice = pricesList.prices[i].open;
                                }

                                const tmpResult = new Object();
                                tmpResult['code'] = pricesList.code;
                                tmpResult['bid'] = pricesAtBid;
                                tmpResult['sell'] = pricesAtSell;
                                upperShadowResult.push(tmpResult);
                                i--;
                                break;
                            }

                            else if (pricesList.prices[i].barType == -1) {
                                if (!pricesList.prices[i + 1]) {
                                    break;
                                }
                                // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                                const pricesAtSell = pricesList.prices[i + 1];
                                pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                                const tmpResult = new Object();
                                tmpResult['code'] = pricesList.code;
                                tmpResult['bid'] = pricesAtBid;
                                tmpResult['sell'] = pricesAtSell;
                                upperShadowResult.push(tmpResult);
                                i--;
                                break;
                            } else {
                                // 利確のために1本前の終値で指値を入れる
                                sashine = pricesList.prices[i - 1].close;
                            }
                        }
                    }
                }
            }
        }
    }


}

/**
 * 2連下ヒゲでのシミュレーション
 */
function simulate2RenLowerShadow() {

    const pricesListNum = Object.keys(pricesListList).length;
    if (pricesListNum == 0) {
        return;
    }
    LowerShadow2RenResult.length = 0;
    for (var listListIndex = 0; listListIndex < pricesListNum; listListIndex++) {
        var pricesList = pricesListList[listListIndex];

        for (var i = 0; i < pricesList.prices.length; i++) {

            // 価格帯絞り込みの範囲外の値段のものはスルーする
            if (Number(pricesList.prices[i].close) < priceBandLow || Number(pricesList.prices[i].close) > priceBandHigh) {
                continue;
            }

            // 下ヒゲが一定の長さを超えたら次のヒゲを調べる
            if (pricesList.prices[i].ls >= purchaseTrigger2RenLsLength) {
                // 次の下ヒゲ、その次のヒゲが存在しない場合はスルー
                if (!pricesList.prices[i + 1] || !pricesList.prices[i + 2]) {
                    break;
                }
                // 2個目のヒゲの下ヒゲを調べる
                i++;
                if (pricesList.prices[i].ls >= purchaseTrigger2RenLsLength) {

                    if (purchasePattern == PATTERN_NARIYUKI) {
                        // 2個目のヒゲも条件を満たしたら購入。次のヒゲの始値で購入するため、次のヒゲのデータを記憶する
                        const pricesAtBid = pricesList.prices[i + 1];
                        pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                        i++;
                        for (; i < pricesList.prices.length; i++) {
                            // 購入後、陰線が出るまで保有し続ける。陰線が出たら売却。売却時も次の足の始値で売却するため、次の足のデータが存在しない場合はスルーする。
                            if (pricesList.prices[i].barType == -1) {
                                if (!pricesList.prices[i + 1]) {
                                    break;
                                }
                                // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                                const pricesAtSell = pricesList.prices[i + 1];
                                pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                                const tmpResult = new Object();
                                tmpResult['code'] = pricesList.code;
                                tmpResult['bid'] = pricesAtBid;
                                tmpResult['sell'] = pricesAtSell;
                                LowerShadow2RenResult.push(tmpResult);
                                i--;
                                break;
                            }
                        }
                    }
                    else if (purchasePattern == PATTERN_GENZAINESASHINE) {
                        if (pricesList.prices[i].close == pricesList.prices[i + 1].open) {
                            // 当足の終値と次の足の始値が一緒だった場合にのみ購入する。これも次の足の始値で購入。
                            const pricesAtBid = pricesList.prices[i + 1];
                            pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                            i++;
                            for (; i < pricesList.prices.length; i++) {
                                // 購入後、陰線が出るまで保有し続ける。陰線が出たら売却。売却時も次の足の始値で売却するため、次の足のデータが存在しない場合はスルーする。
                                if (pricesList.prices[i].barType == -1) {
                                    if (!pricesList.prices[i + 1]) {
                                        break;
                                    }
                                    // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                                    const pricesAtSell = pricesList.prices[i + 1];
                                    pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                                    const tmpResult = new Object();
                                    tmpResult['code'] = pricesList.code;
                                    tmpResult['bid'] = pricesAtBid;
                                    tmpResult['sell'] = pricesAtSell;
                                    LowerShadow2RenResult.push(tmpResult);
                                    i--;
                                    break;
                                }
                            }
                        }
                    }
                    else if (purchasePattern == PATTERN_GENZAINESASHINE_RIKAKU) {
                        if (pricesList.prices[i].close == pricesList.prices[i + 1].open) {
                            // 当足の終値と次の足の始値が一緒だった場合にのみ購入する。これも次の足の始値で購入。
                            const pricesAtBid = pricesList.prices[i + 1];
                            pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                            i++;
                            var sashine = 0;
                            for (; i < pricesList.prices.length; i++) {

                                /*
                                指値を下回った場合、売却する。
                                その足の安値が指値を下回っていた場合、その足の途中で指値を突破したことが確定するので、
                                その足の安値が指値を下回っていた場合に指値で売却処理をする
                                */
                                if (pricesList.prices[i].low <= sashine) {
                                    const pricesAtSell = pricesList.prices[i];

                                    /*
                                    基本的に指値の値段で売却することになるが、当足がめっちゃ窓開けて下げてスタートした場合、
                                    始値が指値を下回ってしまうことがあるので、その場合はもちろん指値で売ることは不可能なので
                                    始値で売却処理をする
                                    */
                                    if (sashine <= pricesList.prices[i].open) {
                                        pricesAtSell.sellingPrice = sashine;
                                    } else {
                                        pricesAtSell.sellingPrice = pricesList.prices[i].open;
                                    }

                                    const tmpResult = new Object();
                                    tmpResult['code'] = pricesList.code;
                                    tmpResult['bid'] = pricesAtBid;
                                    tmpResult['sell'] = pricesAtSell;
                                    LowerShadow2RenResult.push(tmpResult);
                                    i--;
                                    break;
                                }

                                else if (pricesList.prices[i].barType == -1) {
                                    if (!pricesList.prices[i + 1]) {
                                        break;
                                    }
                                    // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                                    const pricesAtSell = pricesList.prices[i + 1];
                                    pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                                    const tmpResult = new Object();
                                    tmpResult['code'] = pricesList.code;
                                    tmpResult['bid'] = pricesAtBid;
                                    tmpResult['sell'] = pricesAtSell;
                                    LowerShadow2RenResult.push(tmpResult);
                                    i--;
                                    break;
                                } else {
                                    // 利確のために1本前の終値で指値を入れる
                                    sashine = pricesList.prices[i - 1].close;
                                }
                            }
                        }
                    }
                }

            }
        }
    }

}

/**
 * 底値下ヒゲでのシミュレーション
 */
function simulateLsInBottom() {

    const pricesListNum = Object.keys(pricesListList).length;
    if (pricesListNum == 0) {
        return;
    }
    LsInBottomResult.length = 0;
    for (var listListIndex = 0; listListIndex < pricesListNum; listListIndex++) {
        var pricesList = pricesListList[listListIndex];

        for (var i = areasJudgementStandardLsInBottom; i < pricesList.prices.length; i++) {

            // 価格帯絞り込みの範囲外の値段のものはスルーする
            if (Number(pricesList.prices[i].close) < priceBandLow || Number(pricesList.prices[i].close) > priceBandHigh) {
                continue;
            }

            // 過去areasJudgementStandardLsInBottom個分の足の安値の中でもっとも安い安値を特定する
            minLowInArea = pricesList.prices[i - 1].low;
            for (var j = 2; j < areasJudgementStandardLsInBottom; j++) {
                if (minLowInArea > pricesList.prices[i - j].low) {
                    minLowInArea = pricesList.prices[i - j].low;
                }
            }

            // 過去areasJudgementStandardLsInBottom個分の足の安値の中でもっとも安い安値よりpricesList.prices[i]の安値が安かったら、底値確定
            if (pricesList.prices[i].low < minLowInArea) {
                // 底値かつ下ヒゲの長さが特定の長さを超えたら購入
                if (pricesList.prices[i].ls >= purchaseTriggerLsInBottomLength) {
                    // 購入時は次の足の始値で購入するため、次の足が存在しない場合はスルー
                    if (!pricesList.prices[i + 1]) {
                        break;
                    }
                    if (purchasePattern == PATTERN_NARIYUKI) {
                        // 次の足の始値で購入する。購入時点のデータを記憶しておく。bid=入札、らしい
                        const pricesAtBid = pricesList.prices[i + 1];
                        pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                        i++;
                        for (; i < pricesList.prices.length; i++) {
                            // 購入後、陰線が出るまで保有し続ける。陰線が出たら売却。売却時も次の足の始値で売却するため、次の足のデータが存在しない場合はスルーする。
                            if (pricesList.prices[i].barType == -1) {
                                if (!pricesList.prices[i + 1]) {
                                    break;
                                }
                                // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                                const pricesAtSell = pricesList.prices[i + 1];
                                pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                                const tmpResult = new Object();
                                tmpResult['code'] = pricesList.code;
                                tmpResult['bid'] = pricesAtBid;
                                tmpResult['sell'] = pricesAtSell;
                                LsInBottomResult.push(tmpResult);
                                i--;
                                break;
                            }
                        }
                    }
                    else if (purchasePattern == PATTERN_GENZAINESASHINE) {
                        if (pricesList.prices[i].close == pricesList.prices[i + 1].open) {
                            // 当足の終値と次の足の始値が一緒だった場合にのみ購入する。これも次の足の始値で購入。
                            const pricesAtBid = pricesList.prices[i + 1];
                            pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                            i++;
                            for (; i < pricesList.prices.length; i++) {
                                // 購入後、陰線が出るまで保有し続ける。陰線が出たら売却。売却時も次の足の始値で売却するため、次の足のデータが存在しない場合はスルーする。
                                if (pricesList.prices[i].barType == -1) {
                                    if (!pricesList.prices[i + 1]) {
                                        break;
                                    }
                                    // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                                    const pricesAtSell = pricesList.prices[i + 1];
                                    pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                                    const tmpResult = new Object();
                                    tmpResult['code'] = pricesList.code;
                                    tmpResult['bid'] = pricesAtBid;
                                    tmpResult['sell'] = pricesAtSell;
                                    LsInBottomResult.push(tmpResult);
                                    i--;
                                    break;
                                }
                            }
                        }
                    }
                    else if (purchasePattern == PATTERN_GENZAINESASHINE_RIKAKU) {
                        if (pricesList.prices[i].close == pricesList.prices[i + 1].open) {
                            // 当足の終値と次の足の始値が一緒だった場合にのみ購入する。これも次の足の始値で購入。
                            const pricesAtBid = pricesList.prices[i + 1];
                            pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                            i++;
                            var sashine = 0;
                            for (; i < pricesList.prices.length; i++) {

                                /*
                                指値を下回った場合、売却する。
                                その足の安値が指値を下回っていた場合、その足の途中で指値を突破したことが確定するので、
                                その足の安値が指値を下回っていた場合に指値で売却処理をする
                                */
                                if (pricesList.prices[i].low <= sashine) {
                                    const pricesAtSell = pricesList.prices[i];

                                    /*
                                    基本的に指値の値段で売却することになるが、当足がめっちゃ窓開けて下げてスタートした場合、
                                    始値が指値を下回ってしまうことがあるので、その場合はもちろん指値で売ることは不可能なので
                                    始値で売却処理をする
                                    */
                                    if (sashine <= pricesList.prices[i].open) {
                                        pricesAtSell.sellingPrice = sashine;
                                    } else {
                                        pricesAtSell.sellingPrice = pricesList.prices[i].open;
                                    }

                                    const tmpResult = new Object();
                                    tmpResult['code'] = pricesList.code;
                                    tmpResult['bid'] = pricesAtBid;
                                    tmpResult['sell'] = pricesAtSell;
                                    LsInBottomResult.push(tmpResult);
                                    i--;
                                    break;
                                }

                                else if (pricesList.prices[i].barType == -1) {
                                    if (!pricesList.prices[i + 1]) {
                                        break;
                                    }
                                    // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                                    const pricesAtSell = pricesList.prices[i + 1];
                                    pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                                    const tmpResult = new Object();
                                    tmpResult['code'] = pricesList.code;
                                    tmpResult['bid'] = pricesAtBid;
                                    tmpResult['sell'] = pricesAtSell;
                                    LsInBottomResult.push(tmpResult);
                                    i--;
                                    break;
                                } else {
                                    // 利確のために1本前の終値で指値を入れる
                                    sashine = pricesList.prices[i - 1].close;
                                }
                            }
                        }
                    }
                }
            }
        }

    }



}


/**
 * 確定的ダブルはらみでのシミュレーション
 */
function simulateDoubleHarami() {

    const pricesListNum = Object.keys(pricesListList).length;
    if (pricesListNum == 0) {
        return;
    }
    doubleHaramiResult.length = 0;
    for (var listListIndex = 0; listListIndex < pricesListNum; listListIndex++) {
        var pricesList = pricesListList[listListIndex];

        for (var i = 3; i < pricesList.prices.length; i++) {

            // 価格帯絞り込みの範囲外の値段のものはスルーする
            if (Number(pricesList.prices[i].close) < priceBandLow || Number(pricesList.prices[i].close) > priceBandHigh) {
                continue;
            }

            // 1本目が陰線じゃなかった場合はスルーする
            if (pricesList.prices[i - 3].barType != -1) {
                continue;
            }

            // 2本目が陽線じゃなかった場合はスルーする
            if (pricesList.prices[i - 2].barType != 1) {
                continue;
            }

            // 1本目の高値が2本目の高値より低かったら、または1本目の安値が2本目の安値より高かったら、はらみではないのでスルーする。
            if (pricesList.prices[i - 3].high <= pricesList.prices[i - 2].high || pricesList.prices[i - 3].low >= pricesList.prices[i - 2].low) {
                continue;
            }

            // 3本目が陰線じゃなかった場合はスルーする
            if (pricesList.prices[i - 1].barType != -1) {
                continue;
            }

            // 4本目が陽線じゃなかった場合はスルーする
            if (pricesList.prices[i].barType != 1) {
                continue;
            }

            // 3本目の高値が4本目の高値より低かったら、または3本目の安値が4本目の安値より高かったら、はらみではないのでスルーする。
            if (pricesList.prices[i - 1].high <= pricesList.prices[i].high || pricesList.prices[i - 1].low >= pricesList.prices[i].low) {
                continue;
            }

            // ここまでcontinueしないでたどり着いたらダブルはらみ確定

            // 購入時は次の足の始値で購入するため、次の足が存在しない場合はスルー
            if (!pricesList.prices[i + 1]) {
                break;
            }
            if (purchasePattern == PATTERN_NARIYUKI) {
                // 次の足の始値で購入する。購入時点のデータを記憶しておく。bid=入札、らしい
                const pricesAtBid = pricesList.prices[i + 1];
                pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                i++;
                for (; i < pricesList.prices.length; i++) {
                    // 購入後、陰線が出るまで保有し続ける。陰線が出たら売却。売却時も次の足の始値で売却するため、次の足のデータが存在しない場合はスルーする。
                    if (pricesList.prices[i].barType == -1) {
                        if (!pricesList.prices[i + 1]) {
                            break;
                        }
                        // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                        const pricesAtSell = pricesList.prices[i + 1];
                        pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                        const tmpResult = new Object();
                        tmpResult['code'] = pricesList.code;
                        tmpResult['bid'] = pricesAtBid;
                        tmpResult['sell'] = pricesAtSell;
                        doubleHaramiResult.push(tmpResult);
                        i--;
                        break;
                    }
                }
            }
            else if (purchasePattern == PATTERN_GENZAINESASHINE) {
                if (pricesList.prices[i].close == pricesList.prices[i + 1].open) {
                    // 当足の終値と次の足の始値が一緒だった場合にのみ購入する。これも次の足の始値で購入。
                    const pricesAtBid = pricesList.prices[i + 1];
                    pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                    i++;
                    for (; i < pricesList.prices.length; i++) {
                        // 購入後、陰線が出るまで保有し続ける。陰線が出たら売却。売却時も次の足の始値で売却するため、次の足のデータが存在しない場合はスルーする。
                        if (pricesList.prices[i].barType == -1) {
                            if (!pricesList.prices[i + 1]) {
                                break;
                            }
                            // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                            const pricesAtSell = pricesList.prices[i + 1];
                            pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                            const tmpResult = new Object();
                            tmpResult['code'] = pricesList.code;
                            tmpResult['bid'] = pricesAtBid;
                            tmpResult['sell'] = pricesAtSell;
                            doubleHaramiResult.push(tmpResult);
                            i--;
                            break;
                        }
                    }
                }
            }
            else if (purchasePattern == PATTERN_GENZAINESASHINE_RIKAKU) {
                if (pricesList.prices[i].close == pricesList.prices[i + 1].open) {
                    // 当足の終値と次の足の始値が一緒だった場合にのみ購入する。これも次の足の始値で購入。
                    const pricesAtBid = pricesList.prices[i + 1];
                    pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                    i++;
                    var sashine = 0;
                    for (; i < pricesList.prices.length; i++) {

                        /*
                        指値を下回った場合、売却する。
                        その足の安値が指値を下回っていた場合、その足の途中で指値を突破したことが確定するので、
                        その足の安値が指値を下回っていた場合に指値で売却処理をする
                        */
                        if (pricesList.prices[i].low <= sashine) {
                            const pricesAtSell = pricesList.prices[i];

                            /*
                            基本的に指値の値段で売却することになるが、当足がめっちゃ窓開けて下げてスタートした場合、
                            始値が指値を下回ってしまうことがあるので、その場合はもちろん指値で売ることは不可能なので
                            始値で売却処理をする
                            */
                            if (sashine <= pricesList.prices[i].open) {
                                pricesAtSell.sellingPrice = sashine;
                            } else {
                                pricesAtSell.sellingPrice = pricesList.prices[i].open;
                            }

                            const tmpResult = new Object();
                            tmpResult['code'] = pricesList.code;
                            tmpResult['bid'] = pricesAtBid;
                            tmpResult['sell'] = pricesAtSell;
                            doubleHaramiResult.push(tmpResult);
                            i--;
                            break;
                        }

                        else if (pricesList.prices[i].barType == -1) {
                            if (!pricesList.prices[i + 1]) {
                                break;
                            }
                            // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                            const pricesAtSell = pricesList.prices[i + 1];
                            pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                            const tmpResult = new Object();
                            tmpResult['code'] = pricesList.code;
                            tmpResult['bid'] = pricesAtBid;
                            tmpResult['sell'] = pricesAtSell;
                            doubleHaramiResult.push(tmpResult);
                            i--;
                            break;
                        } else {
                            // 利確のために1本前の終値で指値を入れる
                            sashine = pricesList.prices[i - 1].close;
                        }
                    }
                }
            }
        }
    }


}


/**
 * 赤三兵でのシミュレーション
 */
function simulateAkasanpei() {

    const pricesListNum = Object.keys(pricesListList).length;
    if (pricesListNum == 0) {
        return;
    }
    akasanpeiResult.length = 0;
    for (var listListIndex = 0; listListIndex < pricesListNum; listListIndex++) {
        var pricesList = pricesListList[listListIndex];

        for (var i = 0; i < pricesList.prices.length; i++) {

            // 価格帯絞り込みの範囲外の値段のものはスルーする
            if (Number(pricesList.prices[i].close) < priceBandLow || Number(pricesList.prices[i].close) > priceBandHigh) {
                continue;
            }

            // i本目が陽線だった場合次のステップへ
            if (pricesList.prices[i].barType == 1) {
                // 2本目、3本目が存在しなかった場合はスルーする
                if (!pricesList.prices[i + 1] || !pricesList.prices[i + 2]) {
                    break;
                }

                i++;
                // 2本目が陽線だった場合次のステップへ
                if (pricesList.prices[i].barType == 1) {
                    i++;
                    // 3本目が陽線だった場合次のステップへ
                    if (pricesList.prices[i].barType == 1) {

                        // 3本目の上ヒゲが特定の長さを超えたら無効なのでスルーする
                        if (pricesList.prices[i].us >= invalidUsInAkasanpei) {
                            continue;
                        }

                        // 次のヒゲの始値で購入するため、次の足が存在しない場合はスルーする
                        if (!pricesList.prices[i + 1]) {
                            break;
                        }

                        if (purchasePattern == PATTERN_NARIYUKI) {
                            // 次の足の始値で購入
                            const pricesAtBid = pricesList.prices[i + 1];
                            pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                            i++;
                            for (; i < pricesList.prices.length; i++) {
                                // 購入後、陰線が出るまで保有し続ける。陰線が出たら売却。売却時も次の足の始値で売却するため、次の足のデータが存在しない場合はスルーする。
                                if (pricesList.prices[i].barType == -1) {
                                    if (!pricesList.prices[i + 1]) {
                                        break;
                                    }
                                    // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                                    const pricesAtSell = pricesList.prices[i + 1];
                                    pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                                    const tmpResult = new Object();
                                    tmpResult['code'] = pricesList.code;
                                    tmpResult['bid'] = pricesAtBid;
                                    tmpResult['sell'] = pricesAtSell;
                                    akasanpeiResult.push(tmpResult);
                                    i--;
                                    break;
                                }
                            }
                        }
                        else if (purchasePattern == PATTERN_GENZAINESASHINE) {
                            if (pricesList.prices[i].close == pricesList.prices[i + 1].open) {
                                // 当足の終値と次の足の始値が一緒だった場合にのみ購入する。これも次の足の始値で購入。
                                const pricesAtBid = pricesList.prices[i + 1];
                                pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                                i++;
                                for (; i < pricesList.prices.length; i++) {
                                    // 購入後、陰線が出るまで保有し続ける。陰線が出たら売却。売却時も次の足の始値で売却するため、次の足のデータが存在しない場合はスルーする。
                                    if (pricesList.prices[i].barType == -1) {
                                        if (!pricesList.prices[i + 1]) {
                                            break;
                                        }
                                        // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                                        const pricesAtSell = pricesList.prices[i + 1];
                                        pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                                        const tmpResult = new Object();
                                        tmpResult['code'] = pricesList.code;
                                        tmpResult['bid'] = pricesAtBid;
                                        tmpResult['sell'] = pricesAtSell;
                                        akasanpeiResult.push(tmpResult);
                                        i--;
                                        break;
                                    }
                                }
                            }
                        }
                        else if (purchasePattern == PATTERN_GENZAINESASHINE_RIKAKU) {
                            if (pricesList.prices[i].close == pricesList.prices[i + 1].open) {
                                // 当足の終値と次の足の始値が一緒だった場合にのみ購入する。これも次の足の始値で購入。
                                const pricesAtBid = pricesList.prices[i + 1];
                                pricesAtBid.buyingPrice = pricesList.prices[i + 1].open;
                                i++;
                                var sashine = 0;
                                for (; i < pricesList.prices.length; i++) {

                                    /*
                                    指値を下回った場合、売却する。
                                    その足の安値が指値を下回っていた場合、その足の途中で指値を突破したことが確定するので、
                                    その足の安値が指値を下回っていた場合に指値で売却処理をする
                                    */
                                    if (pricesList.prices[i].low <= sashine) {
                                        const pricesAtSell = pricesList.prices[i];

                                        /*
                                        基本的に指値の値段で売却することになるが、当足がめっちゃ窓開けて下げてスタートした場合、
                                        始値が指値を下回ってしまうことがあるので、その場合はもちろん指値で売ることは不可能なので
                                        始値で売却処理をする
                                        */
                                        if (sashine <= pricesList.prices[i].open) {
                                            pricesAtSell.sellingPrice = sashine;
                                        } else {
                                            pricesAtSell.sellingPrice = pricesList.prices[i].open;
                                        }

                                        const tmpResult = new Object();
                                        tmpResult['code'] = pricesList.code;
                                        tmpResult['bid'] = pricesAtBid;
                                        tmpResult['sell'] = pricesAtSell;
                                        akasanpeiResult.push(tmpResult);
                                        i--;
                                        break;
                                    }

                                    else if (pricesList.prices[i].barType == -1) {
                                        if (!pricesList.prices[i + 1]) {
                                            break;
                                        }
                                        // 次の足の始値で売却するため、次の足のデータを記憶しておく。sell=売却、でいいかな？
                                        const pricesAtSell = pricesList.prices[i + 1];
                                        pricesAtSell.sellingPrice = pricesList.prices[i + 1].open;
                                        const tmpResult = new Object();
                                        tmpResult['code'] = pricesList.code;
                                        tmpResult['bid'] = pricesAtBid;
                                        tmpResult['sell'] = pricesAtSell;
                                        akasanpeiResult.push(tmpResult);
                                        i--;
                                        break;
                                    } else {
                                        // 利確のために1本前の終値で指値を入れる
                                        sashine = pricesList.prices[i - 1].close;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

}


/**
 * シミュレートし、結果を表示する
 */
function simulateAndShowResult() {

    console.log('size=' + Object.keys(pricesListList).length);
    console.log(pricesListList);

    simulateRandam();
    simulateLowerShadow();
    simulateUpperShadow();
    simulate2RenLowerShadow();
    simulateLsInBottom();
    simulateDoubleHarami();
    simulateAkasanpei();

    calcAndShowResult('random_result_label', randomResult);
    calcAndShowResult('ls_result_label', lowerShadowResult);
    calcAndShowResult('us_result_label', upperShadowResult);
    calcAndShowResult('ls_2ren_result_label', LowerShadow2RenResult);
    calcAndShowResult('ls_inbottom_result_label', LsInBottomResult);
    calcAndShowResult('double_harami_result_label', doubleHaramiResult);
    calcAndShowResult('akasanpei_result_label', akasanpeiResult);

}

/**
 * 期待値を計算し、表示する
 * @param {string} id 結果を表示するラベルのid
 * @param {Array<JSON>} resultList リザルトリスト
 */
function calcAndShowResult(id, resultList) {
    const resultLabel = document.getElementById(id);
    resultLabel.innerText = '';
    if (resultList.length == 0) {
        resultLabel.innerText = '一度も取引が行われませんでした';
        return;
    }
    var resultEntire = 0;
    var win = 0;
    var lose = 0;
    var draw = 0;
    var equalInterval = 1;

    // [ priceRangeScale.length+1 ][ ]の二次元配列を作成
    var dataByPriceRange = new Array(priceRangeScale.length + 1);
    for (var y = 0; y < priceRangeScale.length + 1; y++) {
        dataByPriceRange[y] = new Array().fill(0);
    }

    // [ periodScale.length ][ ]の二次元配列を作成
    var dataByPeriod = new Array(periodScale.length);
    for (var y = 0; y < periodScale.length; y++) {
        dataByPeriod[y] = new Array().fill(0);
    }

    for (var i = 0; i < resultList.length; i++) {
        const bidPrice = resultList[i].bid.buyingPrice; // 購入時の株価
        const sellPrice = resultList[i].sell.sellingPrice; // 売却時の株価
        // 結果(%) = ( ( 売った時の値段 - 買った時の値段 ) / ( 買った時の値段 ) ) * 100 であってるかな？
        var resultOnOneTrade = ((sellPrice - bidPrice) / bidPrice) * 100;
        resultOnOneTrade = resultOnOneTrade - fee;
        resultEntire += resultOnOneTrade;

        /*
        価格帯別にデータを分類していく。
        なんとなくforin文使ってみたけど、この場合のjはNumberとして認識されていないらしく、EVbyPriceRange[j+1]ってやったらエラーになった。
        普通のforで書けばこれは起こらないんだけど、まぁなんか勉強って意味であえてforin使ったまま頑張ってエラー直しました。
        */
        for (var j in priceRangeScale) {
            // 購入時の値段で、価格帯を分類する
            if (bidPrice <= priceRangeScale[j]) {
                dataByPriceRange[j].push(resultOnOneTrade);
                break;
            }

            // 最後まで分類されなかったやつは、とりえずすごい値段が高いやつなので、「それ以上」のとこに分類する
            if (j == priceRangeScale.length - 1) {
                dataByPriceRange[Number(j) + 1].push(resultOnOneTrade);
            }
        }

        // 期間別にデータを分類していく
        for (var j in periodScale) {
            if (resultList[i].bid.date.getFullYear() == periodScale[j]) {
                dataByPeriod[j].push(resultOnOneTrade);
                break;
            }
        }

        if (bidPrice < sellPrice) {
            win++;
        } else if (bidPrice > sellPrice) {
            lose++;
        } else {
            draw++;
        }

        // 適当にデータの 1/10 , 2/10 ... 地点のデータをトレード履歴として表示する。ちゃんとしたタイミングで買い、ちゃんとしたタイミングで売っているかをユーザーが確認できるようにするため。
        if (i > (resultList.length / 10) * equalInterval) {

            equalInterval++;

            const bidDate = (resultList[i].bid.date.getFullYear() + '').slice(2) + '/' + ('0' + (resultList[i].bid.date.getMonth() + 1)).substr(-2) + '/' + ('0' + resultList[i].bid.date.getDate()).substr(-2);
            const sellDate = (resultList[i].sell.date.getFullYear() + '').slice(2) + '/' + ('0' + (resultList[i].sell.date.getMonth() + 1)).substr(-2) + '/' + ('0' + resultList[i].sell.date.getDate()).substr(-2);

            var plus = '';
            if (bidPrice < sellPrice) {
                plus = '+';
            }
            resultLabel.innerText += resultList[i].code + '　' + bidDate + '~' + sellDate + '　' + (plus + Math.round(resultOnOneTrade * 100) / 100) + '%\n';

        }
    }

    // 期待値がプラスだった場合は数字の先頭に「+」をつける
    var plus = '';
    if (resultEntire > 0) {
        plus = '+';
    }
    const entireEV = resultEntire / resultList.length;
    resultLabel.innerText = '期待値 = ' + plus + entireEV + '%\nトレード回数 : ' + resultList.length + '\n' + win + '勝 ' + lose + '敗 ' + draw + '分け (勝率:' + Math.round(((win * 100) / (win + lose + draw)) * 100) / 100 + '%)\n\n' + resultLabel.innerText;

    // グラフを表示するcanvasタグを、リザルトラベルをもとに取得する
    const canvasElemByPriceRange = $(resultLabel).parent().find('canvas[id=priceRange]')[0];
    if (canvasElemByPriceRange) {
        // canvasが見つかれば、そこにグラフを描画
        createAndDisplayGraphByPriceRange(canvasElemByPriceRange, dataByPriceRange);
    }

    // グラフを表示するcanvasタグを、リザルトラベルをもとに取得する
    const canvasElemByPeriod = $(resultLabel).parent().find('canvas[id=period]')[0];
    if (canvasElemByPeriod) {
        // canvasが見つかれば、そこにグラフを描画
        createAndDisplayGraphByPeriod(canvasElemByPeriod, dataByPeriod);
    }

}


/**
 * 価格帯別のグラフを描画する
 * @param {Element} canvasElem グラフを表示するcanvasエレメント
 * @param {Array} resuList 価格帯別のリザルトリスト
 */
function createAndDisplayGraphByPriceRange(canvasElem, resuList) {
    // 引数でエレメントを受け取る時、idを受け取ったりエレメント本体を受け取ったりと統一性がなくて気持ち悪くなっちゃった。
    // でも直そうと思っても結構きつい

    /*
    すでにグラフが描画されている状態で別のグラフを上から再描画すると、裏に元々のグラフが残ってしまいちょっとバグった。
    それを防ぐためには、new Chart()で返されるオブジェクトをグローバルに保持しておいて、再描画したい時に .update() メソッドを呼ぶとかなんとかネットに書いてあったけど、
    あんまりむやみにグローバル変数を増やしたくなかったので、気合いで別の方法でグラフの再描画を実現した。
    具体的には、最初にいったん<canvas>タグを消して、再度新しい<canvas>タグを生成して同じ場所に配置している。
    */
    const parent = $(canvasElem).parent();
    // いったん<canvas>を消す
    canvasElem.remove();
    const newCanvas = document.createElement('canvas');
    newCanvas.setAttribute('id', 'priceRange');
    // 新しい<canvas>を作成し、同じ場所に配置する
    parent.append(newCanvas);
    canvasElem = $(parent).children('canvas')[0];

    /** 価格帯別グラフのそれぞれの値(期待値) */
    const EVAveByPriceRange = [];
    /** 価格帯別トレード回数トレード回数 */
    const tradeTimesByPriceRange = [];
    /** 価格帯別グラフの目盛り */
    const labels = [];
    for (var i in resuList) {

        // 価格帯別の期待値を求める
        var sum = 0;
        var ave = 0;
        for (var j in resuList[i]) {
            sum += resuList[i][j];
        }
        if (!resuList[i].length == 0) {
            ave = sum / resuList[i].length;
        }

        EVAveByPriceRange.push(ave);

        // 価格帯別のトレード回数を記憶
        tradeTimesByPriceRange.push(resuList[i].length);


        // グラフの目盛りを作成
        var scaleLabelText = '';
        if (i == 0) {
            scaleLabelText = '0 ~ ' + priceRangeScale[i];
        } else if (i == resuList.length - 1) {
            scaleLabelText = (priceRangeScale[Number(i) - 1] + 1) + ' ~ '
        } else {
            scaleLabelText = (priceRangeScale[Number(i) - 1] + 1) + ' ~ ' + priceRangeScale[i];
        }

        labels.push(scaleLabelText);
    }

    // グラフの目盛り調整のため、期待値、トレード回数それぞれの最大値を求める
    var EVmax = 0;
    var tradeTimeMax = 0;
    for (var i in EVAveByPriceRange) {
        if (Math.abs(EVAveByPriceRange[i]) > EVmax) {
            EVmax = Math.abs(EVAveByPriceRange[i]);
        }

        if (tradeTimesByPriceRange[i] > tradeTimeMax) {
            tradeTimeMax = tradeTimesByPriceRange[i];
        }
    }

    var complexChartOption = {
        responsive: true,
        title: {
            display: true,
            fontSize: 18,
            text: '価格帯別'
        },
        scales: {
            yAxes: [{
                id: "EV",   // Y軸のID
                type: "linear",   // linear固定 
                position: "left", // どちら側に表示される軸か？
                ticks: {
                    /*
                    マイナスの期待値がある場合、期待値のグラフとトレード回数のグラフで0の位置がずれてしまうため、
                    グラフの目盛りの最大値と最小値を合わせることで0の位置を真ん中に固定する。
                    最大値の1割分余裕を持たせることで、最大値の棒が天井にくっついてしまうのを防ぐ。
                    */
                    max: EVmax + (EVmax * 0.1),
                    min: -(EVmax + (EVmax * 0.1)),
                }
            }, {
                id: "tradeTime",
                type: "linear",
                position: "right",
                ticks: {
                    max: Math.round(tradeTimeMax + (tradeTimeMax * 0.1)),
                    min: -Math.round((tradeTimeMax + (tradeTimeMax * 0.1))),
                }
            }],
        }
    };

    var myChart = new Chart(canvasElem, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: '期待値',
                data: EVAveByPriceRange,
                backgroundColor: 'rgba(54, 162, 235, 0.6)',
                hoverBackgroundColor: "rgba(54, 162, 300, 1)",
                borderWidth: 1,
                yAxisID: "EV",
            },
            {
                type: 'bar',
                label: 'トレード回数',
                data: tradeTimesByPriceRange,
                backgroundColor: 'rgba(255,99,132,0.3)',
                hoverBackgroundColor: "rgba(255,99,132,0.6)",
                borderWidth: 1,
                yAxisID: "tradeTime"
            }]
        },

        options: complexChartOption
    });

}


/**
 * 期間別のグラフを描画する
 * @param {Element} canvasElem グラフを表示するcanvasエレメント
 * @param {Array} resuList 期間別のリザルトリスト
 */
function createAndDisplayGraphByPeriod(canvasElem, resuList) {

    /*
    すでにグラフが描画されている状態で別のグラフを上から再描画すると、裏に元々のグラフが残ってしまいちょっとバグった。
    それを防ぐためには、new Chart()で返されるオブジェクトをグローバルに保持しておいて、再描画したい時に .update() メソッドを呼ぶとかなんとかネットに書いてあったけど、
    あんまりむやみにグローバル変数を増やしたくなかったので、気合いで別の方法でグラフの再描画を実現した。
    具体的には、最初にいったん<canvas>タグを消して、再度新しい<canvas>タグを生成して同じ場所に配置している。
    */
    const parent = $(canvasElem).parent();
    // いったん<canvas>を消す
    canvasElem.remove();
    const newCanvas = document.createElement('canvas');
    newCanvas.setAttribute('id', 'period');
    // 新しい<canvas>を作成し、同じ場所に配置する
    parent.append(newCanvas);
    canvasElem = $(parent).children('canvas')[0];

    /** 期間別グラフのそれぞれの値(期待値) */
    const EVAveByPeriod = [];
    /** 期間別トレード回数 */
    const tradeTimesByPeriod = [];
    for (var i in resuList) {

        // 期間別の期待値を求める
        var sum = 0;
        var ave = 0;
        for (var j in resuList[i]) {
            sum += resuList[i][j];
        }
        if (!resuList[i].length == 0) {
            ave = sum / resuList[i].length;
        }

        EVAveByPeriod.push(ave);

        // 期間別のトレード回数を記憶
        tradeTimesByPeriod.push(resuList[i].length);

    }

    // グラフの目盛り調整のため、期待値、トレード回数それぞれの最大値を求める
    var EVmax = 0;
    var tradeTimeMax = 0;
    for (var i in EVAveByPeriod) {
        if (Math.abs(EVAveByPeriod[i]) > EVmax) {
            EVmax = Math.abs(EVAveByPeriod[i]);
        }

        if (tradeTimesByPeriod[i] > tradeTimeMax) {
            tradeTimeMax = tradeTimesByPeriod[i];
        }
    }

    var complexChartOption = {
        responsive: true,
        title: {
            display: true,
            fontSize: 18,
            text: '期間別'
        },
        scales: {
            yAxes: [{
                id: "EV",   // Y軸のID
                type: "linear",   // linear固定 
                position: "left", // どちら側に表示される軸か？
                ticks: {
                    /*
                    マイナスの期待値がある場合、期待値のグラフとトレード回数のグラフで0の位置がずれてしまうため、
                    グラフの目盛りの最大値と最小値を合わせることで0の位置を真ん中に固定する。
                    最大値の1割分余裕を持たせることで、最大値の棒が天井にくっついてしまうのを防ぐ。
                    */
                    max: EVmax + (EVmax * 0.1),
                    min: -(EVmax + (EVmax * 0.1)),
                }
            }, {
                id: "tradeTime",
                type: "linear",
                position: "right",
                ticks: {
                    max: Math.round(tradeTimeMax + (tradeTimeMax * 0.1)),
                    min: -Math.round((tradeTimeMax + (tradeTimeMax * 0.1))),
                }
            }],
        }
    };

    var myChart = new Chart(canvasElem, {
        type: 'bar',
        data: {
            labels: periodScale,
            datasets: [{
                label: '期待値',
                data: EVAveByPeriod,
                backgroundColor: 'rgba(54, 162, 235, 0.6)',
                hoverBackgroundColor: "rgba(54, 162, 300, 1)",
                borderWidth: 1,
                yAxisID: "EV",
            },
            {
                type: 'bar',
                label: 'トレード回数',
                data: tradeTimesByPeriod,
                backgroundColor: 'rgba(255,99,132,0.3)',
                hoverBackgroundColor: "rgba(255,99,132,0.6)",
                borderWidth: 1,
                yAxisID: "tradeTime"
            }]
        },

        options: complexChartOption
    });

}




/**
 * inputの中の購入トリガーで再シミュレートする
 */
function recalculationLowerShadow() {
    const inputVal = $('#purchase_trigger_input_ls').val();
    if (!inputVal) {
        return;
    }

    purchaseTriggerLowerShadowLength = Number(inputVal);

    simulateLowerShadow();
    calcAndShowResult('ls_result_label', lowerShadowResult);
}

/**
 * inputの中の購入トリガーで再シミュレートする
 */
function recalculationUpperShadow() {
    const inputVal = $('#purchase_trigger_input_us').val();
    if (!inputVal) {
        return;
    }

    purchaseTriggerUpperShadowLength = Number(inputVal);

    simulateUpperShadow();
    calcAndShowResult('us_result_label', upperShadowResult);
}

/**
 * inputの中の購入トリガーで再シミュレートする
 */
function recalculation2RenLowerShadow() {
    const inputVal = $('#purchase_trigger_input_2ren_ls').val();
    if (!inputVal) {
        return;
    }

    purchaseTrigger2RenLsLength = Number(inputVal);

    simulate2RenLowerShadow();
    calcAndShowResult('ls_2ren_result_label', LowerShadow2RenResult);
}

/**
 * inputの中の購入トリガーで再シミュレートする
 */
function recalculationLsInBottom() {
    const inputVal_area = $('#areas_judgement_standard_input').val();
    const inputVal_trigger = $('#purchase_trigger_input_ls_inbottom').val();
    if (!inputVal_area || !inputVal_trigger) {
        return;
    }

    areasJudgementStandardLsInBottom = Number(inputVal_area);
    purchaseTriggerLsInBottomLength = Number(inputVal_trigger);

    simulateLsInBottom();
    calcAndShowResult('ls_inbottom_result_label', LsInBottomResult);
}

/**
 * inputの中の購入トリガーで再シミュレートする
 */
function recalculationAkasanpei() {
    const inputVal = $('#invalid_us_in_akasanpei_input').val();
    if (!inputVal) {
        return;
    }

    invalidUsInAkasanpei = Number(inputVal);

    simulateAkasanpei();
    calcAndShowResult('akasanpei_result_label', akasanpeiResult);
}



/**
* 上ヒゲの長さを計算する(株価全体に対するパーセンテージ)
* @param {number} open 
* @param {number} high 
* @param {number} low 
* @param {number} close 
*/
function calcUpperShadow(open, high, low, close) {
    var upperShadowLength = high - Math.max(open, close);
    if (upperShadowLength == 0) {
        return 0;
    }
    var upperShadowPercentForAll = (upperShadowLength / high) * 100;

    return upperShadowPercentForAll;
}

/**
 * 下ヒゲの長さを計算する(株価全体に対するパーセンテージ)
 * @param {number} open 
 * @param {number} high 
 * @param {number} low 
 * @param {number} close 
 */
function calcLowerShadow(open, high, low, close) {
    var lowerShadowLength = Math.min(open, close) - low;
    if (lowerShadowLength == 0) {
        return 0;
    }
    var lowerShadowPercentForAll = (lowerShadowLength / high) * 100;

    return lowerShadowPercentForAll;
}

/**
 * 購入条件変更
 * @param {購入条件} pattern 0:成行 1:現在値指値
 */
function selectPurchasePattern(pattern) {
    purchasePattern = pattern;
    const radios = $('#purchase_pattern_radio input');
    for (var i = 0; i < radios.length; i++) {
        if (i == pattern) {
            $(radios[i]).prop('checked', true);
        } else {
            $(radios[i]).prop('checked', false);
        }
    }
}


/**
 * 価格帯絞り込みの範囲を入力フォームの値でセット。
 * 価格帯絞り込み範囲の入力フォームに何か入力されるたびに呼ばれる
 */
function setPriceBand() {
    // 入力された値を価格帯範囲の変数に格納する。
    priceBandLow = $('#price_band_low').val();
    priceBandHigh = $('#price_band_high').val();
}
